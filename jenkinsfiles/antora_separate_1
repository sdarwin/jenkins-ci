pipeline {
    // agent {
    //     node {
    //         label 'jenkinspool1'
    //     }
    // }

    agent {
        docker {
            image 'cppalliance/boost_superproject_build:24.04-v3'
            args '-v /var/lib/jenkins/jenkinsfilecache:/jenkinsfilecache'
        // label 'jenkinspool1'
        }
    }

    stages {
        stage('Preclean Workspace') {
            steps {
                sh '''#!/bin/bash
                set -xe
                rm -rf * .*
                '''
                checkout scm
            }
        }

        stage('Read Params') {
            steps {
                script {
                    try {
                        env.NOTIFIED_BEFORE = params.SAVED_NOTIFIED_BEFORE
                    }
                    catch (Exception e) {
                        env.NOTIFIED_BEFORE = 'false'
                    }
                    if (env.NOTIFIED_BEFORE != 'true') {
                        env.NOTIFIED_BEFORE = 'false'
                    }
                    try {
                        env.COMMENT_ID = params.SAVED_COMMENT_ID
                    }
                    catch (Exception e) {
                        env.COMMENT_ID = 'none'
                    }
                }
            }
        }

        stage('Set Variables') {
            steps {
                sh '''#!/bin/bash -xe
                echo "" > jenkinsjobinfo.sh
                chmod 777 jenkinsjobinfo.sh
                REPONAME=$(basename -s .git "$(git config --get remote.origin.url)")
                # REPONAME=$(basename `git rev-parse --show-toplevel`)
                DNSREPONAME=$(echo $REPONAME | tr '_' '-')
                ORGANIZATION=$(basename $(dirname "${GIT_URL}"))
                if [[ "${GIT_URL}" =~ sdarwin ]]; then
                    # testing environment
                    echo "export JENKINS_CI_REPO=sdarwin/jenkins-ci" >> jenkinsjobinfo.sh
                    echo "export JENKINS_CI_REPO_BRANCH=testing" >> jenkinsjobinfo.sh
                else
                    # standard
                    echo "export JENKINS_CI_REPO=cppalliance/jenkins-ci" >> jenkinsjobinfo.sh
                    echo "export JENKINS_CI_REPO_BRANCH=master" >> jenkinsjobinfo.sh
                fi
                echo "export PRTEST=prtest" >> jenkinsjobinfo.sh
                echo "export REPONAME=${REPONAME}" >> jenkinsjobinfo.sh
                echo "export DNSREPONAME=${DNSREPONAME}" >> jenkinsjobinfo.sh
                echo "export ORGANIZATION=${ORGANIZATION}" >> jenkinsjobinfo.sh
                echo "export ONLY_BUILD_ON_DOCS_MODIFICATION=false" >> jenkinsjobinfo.sh
                echo "export PATH_TO_DOCS=libs/${REPONAME}/doc" >> jenkinsjobinfo.sh
                echo "export ALWAYS_NOTIFY=false" >> jenkinsjobinfo.sh
                '''
            }
        }

        stage('Diagnostics') {
            steps {
                sh '''#!/bin/bash
                set -x
                # not set -e. errors may occur in diagnostics
                cat jenkinsjobinfo.sh
                . jenkinsjobinfo.sh
                ls -al
                cat /etc/os-release
                pwd
                env
                whoami
                ls -al /var/lib/jenkins/
                ls -al /var/lib/jenkins/workspace/
                touch $(date "+%A-%B-%d-%T-%y")
                mount | grep ^/dev/ | grep -v /etc | awk '{print \$3}'
                git branch
                git branch -avv
                true
                '''
            }
        }

        stage('Prebuild script') {
            when {
                anyOf {
                    branch 'develop'
                    branch 'master'
                    branch 'docs'
                    expression { env.CHANGE_ID != null }
                }
            }
            steps {
                sh '''#!/bin/bash
                set -xe
                . jenkinsjobinfo.sh
                curl -f -o jenkins_prebuild_script.sh https://raw.githubusercontent.com/${JENKINS_CI_REPO}/${JENKINS_CI_REPO_BRANCH}/scripts/${ORGANIZATION}_${REPONAME}_prebuild.sh || true
                if [ -f jenkins_prebuild_script.sh ]; then
                    chmod 755 jenkins_prebuild_script.sh
                    ./jenkins_prebuild_script.sh
                fi
                '''
            }
        }

        stage('Check if docs were modified') {
            when {
                anyOf {
                    expression { env.CHANGE_ID != null }
                }
            }
            steps {
                sh '''#!/bin/bash
                set -xe
                . jenkinsjobinfo.sh

                if [ "$ONLY_BUILD_ON_DOCS_MODIFICATION" == "true" ]; then
                    echo "Starting check to see if docs have been updated."
                    git config remote.origin.fetch '+refs/heads/*:refs/remotes/origin/*'
                    git fetch origin ${CHANGE_TARGET}
                    mergebase=$(git merge-base HEAD remotes/origin/${CHANGE_TARGET})
                    counter=0
                    for i in $(git diff --name-only HEAD $mergebase)
                    do
                      echo "file is $i"
                      if [[ $i =~ ^doc/ ]]; then
                        counter=$((counter+1))
                      fi
                    done

                    if [ "$counter" -eq "0" ]; then
                      echo "No docs found. Exiting."
                      # exit 1
                      echo "export AUTOCANCEL=true" >> jenkinsjobinfo.sh
                    else
                      echo "Found $counter docs. Proceeding."
                    fi
                 else
                     echo "Not checking if docs were updated. Always build."
                 fi
                '''
            }
        }

        stage('Determine if the job should exit') {
            when {
                anyOf {
                    expression { env.CHANGE_ID != null }
                }
            }
            environment {
                // See https://www.jenkins.io/doc/book/pipeline/jenkinsfile/#using-environment-variables
                AUTOCANCEL = """${sh(
                  returnStdout: true,
                  script: '#!/bin/bash \n' + 'source jenkinsjobinfo.sh; echo -n "${AUTOCANCEL}"'
              )}"""
            }
            steps {
                script {
                    if (env.AUTOCANCEL == 'true') {
                        currentBuild.result = 'ABORTED'
                        error('Aborting the build.')
                    }
                }
            }
        }

        // To skip this step, and actually all steps, adjust the job's Filter regex in the Jenkins UI
        // (develop|master|PR-.*) will build all branches
        // (PR-.*) will build pull requests. Etc.
        stage('Build docs') {
            when {
                anyOf {
                    branch 'develop'
                    branch 'master'
                    branch 'docs'
                    expression { env.CHANGE_ID != null }
                }
            }

            steps {
                sh '''#!/bin/bash
                set -xe
                . jenkinsjobinfo.sh
                export pythonvirtenvpath=/opt/venvboostdocs
                if [ -f ${pythonvirtenvpath}/bin/activate ]; then
                    source ${pythonvirtenvpath}/bin/activate
                fi

                # Is there a custom build script? Often not. But let's check:

                curl -f -o jenkins_build_script.sh https://raw.githubusercontent.com/${JENKINS_CI_REPO}/${JENKINS_CI_REPO_BRANCH}/scripts/${ORGANIZATION}_${REPONAME}_build.sh || true
                if [ -f jenkins_build_script.sh ]; then
                    chmod 755 jenkins_build_script.sh
                    ./jenkins_build_script.sh
                    exit 0
                fi

                # Otherwise, proceed using standard build steps:

                mkdir -p ~/".nvm_${REPONAME}_antora"
                export NODE_VERSION=18.18.1
                # The container has a pre-installed nodejs. Overwrite those again.
                export NVM_BIN="$HOME/.nvm_${REPONAME}_antora/versions/node/v${NODE_VERSION}/bin"
                export NVM_DIR=$HOME/.nvm_${REPONAME}_antora
                export NVM_INC=$HOME/.nvm_${REPONAME}_antora/versions/node/v${NODE_VERSION}/include/node
                curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.5/install.sh | bash
                export NVM_DIR=$HOME/.nvm_${REPONAME}_antora
                # shellcheck source=/dev/null
                . "$NVM_DIR/nvm.sh" && nvm install ${NODE_VERSION}
                # shellcheck source=/dev/null
                . "$NVM_DIR/nvm.sh" && nvm use v${NODE_VERSION}
                # shellcheck source=/dev/null
                . "$NVM_DIR/nvm.sh" && nvm alias default v${NODE_VERSION}
                export PATH="$HOME/.nvm_${REPONAME}_antora/versions/node/v${NODE_VERSION}/bin/:${PATH}"
                node --version
                npm --version
                npm install gulp-cli@2.3.0
                npm install @mermaid-js/mermaid-cli@10.5.1

                curl -s -S --retry 10 -L -o linuxdocs.sh https://github.com/boostorg/release-tools/raw/develop/build_docs/linuxdocs.sh
                chmod 755 linuxdocs.sh

                # 2024-11 Antora requires a full copy of boostorg/boost which is 2GB. Not ideal. Let us provide that directory here.
                # Since some implementations of antora/mrdocs seem to be using boost-root, symlink the filecache to the boost-root,
                # so it will use the cache no-matter-what (hopefully).
                savedworkspacedir=$(pwd)
                cd /jenkinsfilecache
                if [[ "${JOB_BASE_NAME}" =~ PR ]]; then
                    CACHE_FOLDER="PR"
                    BOOST_BRANCH="develop"
                elif [[ "${JOB_BASE_NAME}" =~ "docs" ]]; then
                    CACHE_FOLDER=${JOB_BASE_NAME}
                    BOOST_BRANCH="develop"
                else
                    CACHE_FOLDER=${JOB_BASE_NAME}
                    BOOST_BRANCH=${BRANCH_NAME}
                fi
                mkdir -p ${REPONAME}/${CACHE_FOLDER}
                cd ${REPONAME}/${CACHE_FOLDER}
                if [ ! -d boost ]; then
                    git clone https://github.com/boostorg/boost -b ${BOOST_BRANCH}
                fi
                cd boost
                # not 'exporting' this, just for the following section.
                BOOST_ROOT=$(pwd)
                git checkout ${BOOST_BRANCH}
                rm -rf libs/${REPONAME}/* || true
                rm -rf libs/${REPONAME}/.* || true
                rm -rf tools/${REPONAME}/* || true
                rm -rf tools/${REPONAME}/.* || true
                git pull
                git submodule update --init
                FILECACHE_PATH=$(pwd)
                # Formatted such as "cppalliance/buffers cppalliance/http_proto"
                if [ -z "${EXTRA_BOOST_LIBRARIES}" ]; then
                    EXTRA_BOOST_LIBRARIES="cppalliance/buffers cppalliance/http_proto"
                fi
                for EXTRA_LIB in ${EXTRA_BOOST_LIBRARIES}; do
                    EXTRA_LIB_REPO=`basename $EXTRA_LIB`
                    if [ ! -d "$BOOST_ROOT/libs/${EXTRA_LIB_REPO}" ]; then
                        pushd $BOOST_ROOT/libs
                        git clone https://github.com/${EXTRA_LIB} -b $BOOST_BRANCH --depth 1
                        popd
                    else
                        # refresh extra lib:
                        pushd $BOOST_ROOT/libs/${EXTRA_LIB_REPO}
                        git checkout $BOOST_BRANCH || true
                        git pull || true
                        popd
                    fi
                done

                cd ..
                cd $savedworkspacedir
                ln -s ${FILECACHE_PATH} boost-root || true
                echo "export FILECACHE_PATH=${FILECACHE_PATH}" >> jenkinsjobinfo.sh
                export BOOST_SRC_DIR=$(pwd)/boost-root

                # </done> 2024-11 Antora requires a full copy of boostorg/boost which is 2GB. Not ideal. Let us provide that directory here.

                ./linuxdocs.sh --debug --boostrootsubdir --skip-packages

                # Fix index.html
                sourcefile=boost-root/libs/${REPONAME}/doc/html/${REPONAME}.html
                destfile=boost-root/libs/${REPONAME}/doc/html/index.html
                if [[ ! -f $destfile && -f $sourcefile ]]; then
                    cp $sourcefile $destfile
                fi
                '''
            }
        }

        stage('Postbuild script') {
            when {
                anyOf {
                    branch 'develop'
                    branch 'master'
                    branch 'docs'
                    expression { env.CHANGE_ID != null }
                }
            }
            steps {
                sh '''#!/bin/bash
                set -xe

                . jenkinsjobinfo.sh
                curl -f -o jenkins_postbuild_script.sh https://raw.githubusercontent.com/${JENKINS_CI_REPO}/${JENKINS_CI_REPO_BRANCH}/scripts/${ORGANIZATION}_${REPONAME}_postbuild.sh || true
                if [ -f jenkins_postbuild_script.sh ]; then
                    chmod 755 jenkins_postbuild_script.sh
                    ./jenkins_postbuild_script.sh
                fi
                '''
            }
        }

        stage('Main branches: Upload to S3') {
            when {
                anyOf {
                    branch 'develop'
                    branch 'master'
                    branch 'docs'
                }
            }

            environment {
                // See https://www.jenkins.io/doc/book/pipeline/jenkinsfile/#using-environment-variables
                REPONAME = """${sh(
                 returnStdout: true,
                 script: '#!/bin/bash \n' + 'source jenkinsjobinfo.sh; echo -n "${REPONAME}"'
             )}"""
                DNSREPONAME = """${sh(
                 returnStdout: true,
                 script: '#!/bin/bash \n' + 'source jenkinsjobinfo.sh; echo -n "${DNSREPONAME}"'
             )}"""
                PATH_TO_DOCS = """${sh(
                 returnStdout: true,
                 script: '#!/bin/bash \n' + 'source jenkinsjobinfo.sh; echo -n "${PATH_TO_DOCS}"'
             )}"""
                FILECACHE_PATH = """${sh(
                 returnStdout: true,
                 script: '#!/bin/bash \n' + 'source jenkinsjobinfo.sh; echo -n "${FILECACHE_PATH}"'
             )}"""
            }

            steps {
                // "usually" what appears here as ${FILECACHE_PATH} would be "boost-root"
                withAWS(region:'us-east-1', credentials: 'cppalliance-bot-aws-user') {
                    s3Upload(bucket:'cppalliance-websites', path:"${BRANCH_NAME}.${DNSREPONAME}.cpp.al", workingDir: "/var/lib/jenkins/${FILECACHE_PATH}/${PATH_TO_DOCS}/html", includePathPattern:'**')
                }
            }
        }

        stage('Pull requests: Upload to S3') {
            when {
                anyOf {
                    expression { env.CHANGE_ID != null }
                }
            }

            environment {
                // See https://www.jenkins.io/doc/book/pipeline/jenkinsfile/#using-environment-variables
                REPONAME = """${sh(
                 returnStdout: true,
                 script: '#!/bin/bash \n' + 'source jenkinsjobinfo.sh; echo -n "${REPONAME}"'
             )}"""
                DNSREPONAME = """${sh(
                 returnStdout: true,
                 script: '#!/bin/bash \n' + 'source jenkinsjobinfo.sh; echo -n "${DNSREPONAME}"'
             )}"""
                PRTEST = """${sh(
                 returnStdout: true,
                 script: '#!/bin/bash \n' + 'source jenkinsjobinfo.sh; echo -n "${PRTEST}"'
             )}"""
                PATH_TO_DOCS = """${sh(
                 returnStdout: true,
                 script: '#!/bin/bash \n' + 'source jenkinsjobinfo.sh; echo -n "${PATH_TO_DOCS}"'
             )}"""
                DIFF2HTML = """${sh(
                 returnStdout: true,
                 script: '#!/bin/bash \n' + 'source jenkinsjobinfo.sh; echo -n "${DIFF2HTML}"'
             )}"""
                ALWAYS_NOTIFY = """${sh(
                 returnStdout: true,
                 script: '#!/bin/bash \n' + 'source jenkinsjobinfo.sh; echo -n "${ALWAYS_NOTIFY}"'
             )}"""
                FILECACHE_PATH = """${sh(
                 returnStdout: true,
                 script: '#!/bin/bash \n' + 'source jenkinsjobinfo.sh; echo -n "${FILECACHE_PATH}"'
             )}"""
            }

            steps {
                withAWS(region:'us-east-1', credentials: 'cppalliance-bot-aws-user') {
                    // "usually" what appears here as ${FILECACHE_PATH} would be "boost-root"
                    s3Upload(bucket:'cppalliance-previews', path:"${DNSREPONAME}/${CHANGE_ID}/${PATH_TO_DOCS}/", workingDir: "/var/lib/jenkins/${FILECACHE_PATH}/${PATH_TO_DOCS}", includePathPattern:'*.html')
                    s3Upload(bucket:'cppalliance-previews', path:"${DNSREPONAME}/${CHANGE_ID}/${PATH_TO_DOCS}/html/", workingDir: "/var/lib/jenkins/${FILECACHE_PATH}/${PATH_TO_DOCS}/html", includePathPattern:'**')
                }
                script {
                    def TIMESTAMP = """${sh(
                        returnStdout: true,
                        script: '#!/bin/bash \n' + 'date -u +"%Y-%m-%d %H:%M:%S UTC"'
                    )}"""

                    def commenttext = "An automated preview of the documentation is available at [https://${env.CHANGE_ID}.${env.DNSREPONAME}.${env.PRTEST}.cppalliance.org/${PATH_TO_DOCS}/html/index.html](https://${env.CHANGE_ID}.${env.DNSREPONAME}.${env.PRTEST}.cppalliance.org/${PATH_TO_DOCS}/html/index.html)"

                    if (ALWAYS_NOTIFY == 'false') {
                            commenttext = commenttext + "\n\nIf more commits are pushed to the pull request, the docs will rebuild at the same URL.\n\n${TIMESTAMP}"
                    }

                        // Per-repo customizations

                    if ( (env.DIFF2HTML != null) && (env.DIFF2HTML == 'true') ) {
                        commenttext = commenttext + "\n\nDiff2html diff: [https://${env.CHANGE_ID}.${env.DNSREPONAME}.${env.PRTEST}.cppalliance.org/${PATH_TO_DOCS}/html/diff.html](https://${env.CHANGE_ID}.${env.DNSREPONAME}.${env.PRTEST}.cppalliance.org/${PATH_TO_DOCS}/html/diff.html)"
                    }

                    echo "Debug info: ALWAYS_NOTIFY ${ALWAYS_NOTIFY} NOTIFIED_BEFORE ${NOTIFIED_BEFORE} COMMENT_ID ${env.COMMENT_ID}"
                    echo 'comment content:'
                    echo "${commenttext}"

                    // Send the PR comment
                    if ( (ALWAYS_NOTIFY == 'true') || (NOTIFIED_BEFORE == 'false')) {
                        echo 'Posting a comment for the first time'
                        def mycomment = pullRequest.comment(commenttext)
                        echo "mycomment is ${mycomment}"
                        env.COMMENT_ID = mycomment.id
                        echo 'New COMMENT_ID from a new comment is:'
                        echo "${env.COMMENT_ID}"
                    }

                    // Update the PR comment
                    if ( (ALWAYS_NOTIFY == 'false') && (NOTIFIED_BEFORE == 'true')) {
                        echo 'Editing a comment'
                        long COMMENT_ID_INT = "$env.COMMENT_ID" as Long
                        pullRequest.editComment(COMMENT_ID_INT, commenttext)
                    }
                }
            }
        }

        stage('Post Diagnostics') {
            steps {
                sh '''#!/bin/bash
                set -x
                # not set -e. errors may occur in diagnostics
                cat jenkinsjobinfo.sh
                . jenkinsjobinfo.sh
                ls -al
                cat /etc/os-release
                pwd
                env
                whoami
                touch $(date "+%A-%B-%d-%T-%y")
                mount | grep ^/dev/ | grep -v /etc | awk '{print \$3}'
                git branch
                git branch -avv
                true
                '''
            }
        }

        stage('Save Variables for next run') {
            steps {
                script {
                    properties([
            parameters([
              string(defaultValue: 'true', description: 'Saved Notified Before', name: 'SAVED_NOTIFIED_BEFORE', trim: true),
              string(defaultValue: "$env.COMMENT_ID", description: 'Saved Comment ID', name: 'SAVED_COMMENT_ID', trim: true)
            ])
          ])
                }
            }
        }
    }

    post {
            always {
                echo 'This will always run'
                script {
                    env.PRSTATE = sh(script: ". ./jenkinsjobinfo.sh ; result=\$(curl -L -H \"Accept: application/vnd.github+json\" -H \"X-GitHub-Api-Version: 2022-11-28\" https://api.github.com/repos/\$ORGANIZATION/\$REPONAME/pulls/${env.CHANGE_ID} 2>/dev/null | jq -r '.state'); echo \$result", returnStdout: true).trim()
                }
            }
            success {
                echo 'This will run only if successful'
            // no email on success
            // mail bcc: '', body: "<b>prstate: ${env.PRSTATE}</b><br>Project: ${env.JOB_NAME} <br>Build Number: ${env.BUILD_NUMBER} <br> URL of the build: ${env.BUILD_URL}", cc: '', charset: 'UTF-8', from: '', mimeType: 'text/html', replyTo: '', subject: "SUCCESS CI: Project name -> ${env.JOB_NAME}", to: "jenkins@cppalliance.org";
            }
            failure {
                echo 'This will run only if failure'
                script {
                    if (env.PRSTATE == 'closed') {
                        echo 'No email about a closed PR.'
                    }
                    else {
                        mail bcc: '', body: "<b>prstate: ${env.PRSTATE}</b><br>Project: ${env.JOB_NAME} <br>Build Number: ${env.BUILD_NUMBER} <br> URL of the build: ${env.BUILD_URL}", cc: '', charset: 'UTF-8', from: '', mimeType: 'text/html', replyTo: '', subject: "ERROR CI: Project name -> ${env.JOB_NAME}", to: 'jenkins@cppalliance.org'
                    }
                }
            }
            unstable {
                echo 'This will run only if the run was marked as unstable'
                mail bcc: '', body: "<b>prstate: ${env.PRSTATE}</b><br>Project: ${env.JOB_NAME} <br>Build Number: ${env.BUILD_NUMBER} <br> URL of the build: ${env.BUILD_URL}", cc: '', charset: 'UTF-8', from: '', mimeType: 'text/html', replyTo: '', subject: "UNSTABLE STATUS CI: Project name -> ${env.JOB_NAME}", to: 'jenkins@cppalliance.org'
            }
            changed {
                echo 'This will run only if the state of the Pipeline has changed'
                echo 'For example, if the Pipeline was previously failing but is now successful'
            // no email on changed status
            // mail bcc: '', body: "<b>prstate: ${env.PRSTATE}</b><br>Project: ${env.JOB_NAME} <br>Build Number: ${env.BUILD_NUMBER} <br> URL of the build: ${env.BUILD_URL}", cc: '', charset: 'UTF-8', from: '', mimeType: 'text/html', replyTo: '', subject: "CHANGED STATUS CI: Project name -> ${env.JOB_NAME}", to: "jenkins@cppalliance.org";
            }
    }
}
